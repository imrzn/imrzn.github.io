---
title: 'File attachments in your database'
description: ''
image:
  src: https://raw.githubusercontent.com/xataio/mdx-blog/main/images/date-time-picker-for-databases.png
  alt: file attachments
author: Sorin Toma
date: 08-27-2023
published: true
slug: file-attachments-database
---

Both files and relational data are ubiquitous in today’s applications. Even the most basic scenarios generally require both structured, relational data and file storage. Think about a blog which uses both metadata and images or a product catalog or document library. They all require basic data record management, query capabilities, but also storage and access to large binary objects like images, videos, documents.

It's common practice for engineers to use a relational database and a storage service to store the data used by their application. In most cases, the binary files are related to the relational data, therefore the common pattern is to store a file link in the database.

With the new [file attachments](/docs/concepts/file-attachments) support, Xata aims to simplify this pattern and bring a new experience for building data apps that require binary storage. 

Let’s take a deeper look into what gets simplified and how does Xata achieves this.

When working on our new file attachments feature, we had the following goals in mind:

* Relational and storage APIs should share the same endpoints and the same connections. It is easier to work with and maintain one service rather than two.
* APIs must share the same authorization scheme and the same permissions model. We should avoid having to use different credentials and keep permissions in sync.
* Both data types should reside in the same compliance boundary and have similar guarantees. For example, if a database is in us-east-1, the files will be there too, even though us-east-2 shares compliance boundaries.

Our design process began by recognizing that relational data and large binary objects have distinct consumption models. Trying to incorporate both into the same storage service would result in unacceptable compromises - one size does not fit all! To briefly explain, serving large binary objects from a relational database can't match the performance of a dedicated storage service in terms of compute cost, concurrency, and throughput. Conversely, a storage service can't match the querying and data management capabilities of a relational database.

Like with any design challenge, we had to devise a solution to address seemingly conflicting requirements. The APIs for relational data and binary objects needed to be unified, while the backend storage had to differ to achieve the expected performance and feature set.


## Introducing the file column type

At the API and database schema level, the binary object data type became the file column type. This allowed all existing Xata features to work with the file type without any API change. Using the existing Xata APIs, either REST or Xata SDKs, using the same connection, a developer can now:

* Upload a file
* Download a file
* Run queries over files using filters, aggregations, and joins
* Run search queries to match file metadata.

In the API record model the file column holds a JSON object with a predefined schema which contains both file metadata and the file content.

```json
{
    "name": "sample.png",
    "mediaType": "image/png",
    "size": 75,
    "version": 1,
    "attributes": {
      "height": 2,
      "width": 2
    },
		"base64Content": "iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAYAAABytg0kAAAAEklEQVR42mNk+M9QzwAEjDAGACCDAv8cI7IoAAAAAElFTkSuQmCC",
}
```

### Dual storage

Behind the scenes, the data is actually stored differently. The file content is stored as an AWS S3 object while the file metadata (name, type, size, S3 pointer) is stored as a JSON object in the PostgreSQL database table.

We chose S3 for the binary object storage for its high performance, durability, availability, and because it shares the same compliance certifications with AWS Aurora, which we use for running PostgreSQL. This way, all data (relational and binary objects) is located in the same data centers and benefits from the same compliance guarantees.

The fundamental challenge when writing state to 2 different services is making it transactional. Xata service implements 2-phase commit semantics to ensure that a file write either completes successfully or it is rolled back. This is one of the key operations where Xata does the heavy lifting and abstracts away the complexity. The client code can rely on the transactional guarantee and no longer be concerned with 2-phase commit or dealing with out of sync state.

A second set of challenges comes around data deletion and cleanup, where again it is not trivial to keep the state in sync between 2 services. With database tables, Xata takes the cautious approach of delayed cleanup. This allows us to offer undo delete operations (not exposed yet) and to have a general recovery option in case of accidental deletes. When file storage comes into the picture, it needs to follow the same pattern. Restoring only half of the deleted data is not particularly useful.

The implemented solution treats the PostgreSQL data as source of truth and removes the associated file data only when the corresponding records are deleted from PostreSQL. This is achieved by hooking into the PostgreSQL replication and handling delete record events. This is an elegant way of replicating the deleted state from Postgresql to S3, but unfortunately it is only half the solution, because it only handles individual record or value deletes. When data is deleted by dropping entire columns, tables, databases the events are not captured in replication so Xata handles this separately by scheduling bulk deletes.

Backup support adds another level of complexity. Xata creates regular backups and can perform a restore on request. The binary object storage needs to match the ability to restore the state from the time of the database backup. This is achieved through a combination of immutable S3 objects (we’ll go into details later in this post) and configuring S3 lifecycle. Deleted files become inaccessible, but they are kept for 7 days after their deletion for recovery purposes. After the 7 days the files are permanently deleted.

![File Attachments](/images/attachments-architecture-diagram.png)


### API considerations

If you look at the file column value above, it might strike you as odd. Files don’t come encoded as base64 and they are certainly not used in their encoded form.

Xata APIs are JSON based and therefore the file content needed to fit in a json object. We chose to use base64 encoding as it is the most common binary encoding and has the widest library support across languages. For a client application that has binary content in a buffer it should be trivial to encode it as base64. Xata SDK offers helpers here (docs link).

While we recommend this approach when dealing with small files and when extending existing apps that already use Xata APIs, we acknowledge there are drawbacks in using the base64 encoding. For very large files or for very high throughput applications, the extra CPU cost of encoding and decoding the files begins to matter and it is perceived in the latency. Also the extra 33% in file size added by the encoding impacts the size on the wire and implicitly the performance and bandwidth costs.

To alleviate these concerns we introduced binary file APIs (docs link). The APIs use similar endpoints but they accept and they retrieve binary content. For files larger than 20MB these are the only APIs for uploading content.

It is important to mention these are still database APIs, they involve reads and writes of metadata to PostgreSQL and they are not direct S3 wrappers.


### Read and write patterns

Thinking further about typical relational data use cases and file storage use cases, we noticed significant commonalities and differences. The management of files maps very well to relational data management. Basically CRUD operations are similar in the sense that they work over organized data, entries have owners, there is a permission model in place, they offer a level of consistency and durability. In general we can say that the write patterns are fairly similar. An application for managing files can very well use a database API to achieve the same.

The important difference comes with the read patterns. Relational databases are designed for complex queries, which can involve high usage of CPU and memory, while storage reads have minimal CPU and memory usage. Because the operations are extremely simple, the storage reads generally scale to much higher request rate, concurrency and throughput. Therefore storage read patterns expect very high concurrency and throughput with minimal cost. Offering the database read for files retrieval will not meet the expectations for a storage service.

We will call this high scale read use case, the content distribution scenario.

To address content distribution, Xata introduces direct access URLs. They can be retrieved by reading the file column. Accessing the URL does not involve a database call and therefore they are NOT subject to Xata concurrency and rate limits and they can make use of the storage service capacity.


### Authentication/Authorization

Since the file storage APIs share the same endpoints with the Xata’s common APIs, the same authorization scheme applies. Whether you are using API keys or OAuth, the same credentials can be used for managing files. This single service approach reduces complexity on the client side and at the same time guarantees that future authorization methods and future permissions models apply uniformly to both records API and file storage API.

As we discussed in the previous section, there are 2 distinct usage scenarios for files. The first is the common relational data approach where the operations are file CRUD and metadata query. The common authorization applies here. Access to the file is conditioned by the user having access to the database record.

The second scenario is the content distribution through direct access URLs. In this case the authorization requirements are very different. If resource management requires a trusted security model, content distribution sometimes requires unrestricted access.

To cater for different URL access needs, Xata provides 3 levels of authorization for the URLs that it generates

1. Public Access - the requests to retrieve the file are not subject to any authentication or authorization. This is very convenient for truly public content, but can be very dangerous if configured by mistake on sensitive data. By default, all uploaded files are private (the access URL requires authentication). Public access can be configured per file to allow maximum flexibility. The default can be updated per column, for scenarios where all files need to be public.
2. Signed URL - Xata can generate a signed URL which grants access to anyone having the URL for a specified amount of time. This is commonly used in scenarios where an image is rendered but the URL cannot be further shared because it expires shortly. The default timeout is 1 minute, but it can be configured per file.
3. Authenticated URL - the requests need to include a valid Authorization header in order to retrieve the file.

All the access URLs offer lower latency compared to file retrieval through the common API because, apart from the authorization check (for signed and authenticated URLs) they go directly to storage skipping Xata middleware and the database service.


### CDN

Going further on storage performance, for today’s global applications it is a basic requirement to have consistent good performance across the globe.

We could not claim to simplify working with files and then ask customers to configure and manage their own CDN to get reasonable global performance. Hence the file attachments support comes with CDN included. There is no opt-in and no configuration necessary. All direct access URLs are served through a CDN by default. In essence, all files retrieved through URL are cached at the edge, making the following requests blazing fast.

Xata opted to integrate Cloudflare’s CDN for its wide geographical coverage, its performance and its feature set.

As with any cache, the great performance improvement comes with a the fundamental problem of stale cache entries and cache invalidation. Xata addresses stale cache entries by design using immutable file objects. This means any update to a file is in fact a new file object with a different id generating a different URL and eventually a different cache entry. This pattern is also known as *versioning*, because conceptually the cache keys change with every version of the object.

Following this pattern, when the client application loads a set of records from Xata, it also gets the most up-to-date URLs which are guaranteed NOT to hit a stale cache entry, no matter where the cache is (browser, web proxy, CDN). This is very important because the user can clear the browser cache and Xata service can invalidate the CDN cache, but a web proxy in between might still serve a stale cache entry. Versioning guarantees this can never happen. The downside is that file URLs are not persistent and they should not be used as static resources. However, this fits the Xata model of attaching binary objects to database records. Similar to the database records, the URLs are dynamic content and needs to be retrieved through database reads and queries.

We have seen that content cannot be stale, but there is an important note on permissions. When a public object gets cached, changing permissions will not invalidate the cache entry. Making a file private applies immediately for new URLs, but the file is still accessible through old URLs until the cache entry expires in 2h. Xata advises greatest caution when configuring public access, because in practice there is a delay in changing the permissions from public to private.


### Image Transformations

Looking at the most common scenarios where relational data is used together with binary files, the images case stands out. All web applications use images today and images tend to require processing before they are rendered. Xata file attachments come with a comprehensive set of image transformations, from resizing and photo adjustments to changing format and compression.

All transformations are applied at the edge and are cached by default. Again Xata leverages Cloudflare functionality for image transformations. 

We considered more flexible transformation definitions through query parameters or request body objects, but in the end chose the industry standard of defining the transformations in the URL path. This makes it easier to embed the transformation into a web page and also the transformation is automatically included in the cache key in the CDN.

```json
https://eu-west-1.storage.xata.sh/transform/rotate=180,height=50/nj42n37o4l3dd19fe6vsh4plkk
```

### Conclusion

To conclude, Xata is simplifying the patterns of working with relational data and binary objects together. If you are facing any of the problems described in this post, you are welcomed to give Xata a try!